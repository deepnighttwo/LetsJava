
# Java 的版本为什么这么跳跃

Java 安装好后，使用`java -version`查看 Java 版本，会发现有个奇怪的问题。说好的安装的 Java 8，怎么就变成 Java 1.8 了呢？比如我安装的Zulu JDK8，输出的内容是

```
openjdk version "1.8.0_212"
OpenJDK Runtime Environment (Zulu 8.38.0.13-CA-macosx) (build 1.8.0_212-b04)
OpenJDK 64-Bit Server VM (Zulu 8.38.0.13-CA-macosx) (build 25.212-b04, mixed mode)
```

其实这个根源来自Java本身的版本管理和商业宣传的区别。

# Java 历史上那些重要的版本

Java也是从1.0开始的。但是真正让Java发迹的，是1.2版本。基本上Java所有重要的功能和架构设计，在那个版本都确定了。

而Java1.4，进一步丰富了Java的功能，扩充了类库和实用的语法功能，是一个让Java站在编程语言之巅的版本。

总所周总，软件的版本一般是按照x.y.z定的。x是大版本，一般大版本的升级，代表向后不再兼容。y是小版本，小版本的升级，可能会带来新的功能或者重要的安全升级，但是不会影响向后向前的兼容性。z是代表小的bugfix等影响很小的改动，一般不会有新的功能。

但是尴尬的事情就发生了。Java的系统架构已经很不错了，不大可能会有不兼容的改动。其次，Java在1.4版本的时候已经被很多公司大规模使用了，为了自身的生态健康，也不会作出新版本Java不兼容老版本代码的事情。那么，Java还要不要升级主版本呢？

# Java 5开始的命名规则变化

从商业宣传上考虑，每次都是升级一个小版本，很不给力啊。不够如雷贯耳啊。宣传很不带感有木有。

所以当时Java的拥有者Sun公司（后来被Oracle收购）决定，以后Java的主版本不再动，对外宣传，都以次版本号为Java版本。

也就是说，从Java 1.5开始，Java实际上在商业宣传上，就叫 Java 5了。

但是咱们搞软件的，不在乎商业宣传的那一套，还是遵循着“只要向后兼容没问题，主版本就不升级”的规则。安装包里还是诚实的使用1.几这种格式。所以`java -version`看Java的版本，还是1.几

说到这里大家应该能明白了，其实Java11，就是Java 1.11。

这里还有个趣事，就是在Java 5的时候，也是出于宣传效果，会给每个Java版本取一个动物作为代号。我清楚的记得Java 5的代号是Tiger。Java 6的代号是野马。后来可能发现这个命名策略对宣传也没太大效果吧，还是直接用版本号宣传了。

## Java每个版本的变化

既然每次Java的版本只是升级了一个小版本，其实每次增加的，就是一些新的功能。对已经有的功能和语法，基本没有改动。

你可以认为，Java的每个版本，就相当于LOL里，多了一个英雄，或者对一些英雄的技能做了微调。LOL还是那个LOL，玩起来也没啥大的不同。新的英雄，也不见的比老的英雄好用，而且新的英雄怎么用才能用的好，要经过大家的摸索和磨合。所以对待Java版本升级这件事情上，没必要操之过急。学习的时候，用新的版本也可以，用业内大规模使用的版本也足够。

## LTS 版本

Oracle收购了Java之后，制定了一个LTS版本的规则。LTS就是Long Time Support的缩写。奇数版本是LTS版本，偶数版本是类似于实验版本。LTS版本会提供长期（几年这种时间跨度）的支持，包括安全升级等。非LTS版本会带上一些实验性质的功能，稳定性不太好，而且不会提供长时间的安全升级，简单来说，不适合正式的使用在生产环境，适合技术流玩票尝鲜。

# 总结

- Java 1.x 就是 Java x。比如Java 1.8 就是 Java 8。
- 使用业界现在普遍使用的Java版本即可。每个版本差别并不大，新增的功能也未必成熟好用。这里给出一个有心人总结的Java每个版本新增的功能：https://howtodoinjava.com/java-version-wise-features-history/








